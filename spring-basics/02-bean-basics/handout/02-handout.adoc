= Beans und der ApplicationContext
:author: Kacper Bak
:imagesdir: ../../../images

== Das Domain Model
* Bildet die Grundlage für weitre Beispiele

image::02-spring-basics-004.png[02-spring-basics-004.png, align="center"]

== Bean Definition

* Eine einfache _Bean_ benötigt nur die Angabe der Klasse auf welche sie referenziert.

++++
<script src="https://gist.github.com/KacperBak/5fbbc3738446a7ee8901.js"></script>
++++

* Solange nur eine Instanz von von einem Typ im ApplicationContext vorhanden ist, kann Spring eindeutig daruf zugreifen.

++++
<script src="https://gist.github.com/KacperBak/a7649de88e42435d86f9.js"></script>
++++

.Setter Injection
* Die Verwendung des +property+ Tags greift auf den +setter()+ einer Java Klasse zu.

++++
<script src="https://gist.github.com/KacperBak/f75795f1a0d938dce651.js"></script>
++++

* Dies ist gleichwertig mit ...

++++
<script src="https://gist.github.com/KacperBak/2838842f6489a6507075.js"></script>
++++

.Constructor Injection
* Die Verwendung des +constructor-arg+ Tags greift auf den +ctor()+ einer Java Klasse zu.

++++
<script src="https://gist.github.com/KacperBak/631ad5e03282a45dbf55.js"></script>
++++

* Dies ist gleichwertig mit ...

++++
<script src="https://gist.github.com/KacperBak/a46671ead794fc50809d.js"></script>
++++

.Bean Referenzierung
Beide _Beans_ leiten von +BookingDate+ ab.

++++
<script src="https://gist.github.com/KacperBak/97889db18fa3bdaa8381.js"></script>
++++

* Spring erwartet eine eindeutige Identifikation der Beans.
* Bestehen von einem Typ zwei Instanzen auf die nicht eindeutig referenziert werden kann wirft Spring eine +NoUniqueBeanDefinitionException+.

++++
<script src="https://gist.github.com/KacperBak/d36b7a685e1b8eac926e.js"></script>
++++

* Dies trifft in der zweiten Zeile zu, da auf den gemeinsame Typ +BookingDate+ referenziert wird.

.Bean Referenzierung mit _Id_'s
* Um _Beans_  eindeutig zu identifizieren, wird das _Id_ Attribut  +id="myBean"+ verwendet.
* Um auf _Beans_ zu referenzieren, wird das _ref_ Attribut  +ref="myBean"+ eingesetzt.

++++
<script src="https://gist.github.com/KacperBak/1f95256a1357e20a2624.js"></script>
++++

.Inner bean
* Eine Möglichkeit eine eindeutige _Bean_ zu definieren *ohne*  eine eindeutige _Id_ zu vergeben!
* Kein äußerer Zugriff mit +getBean()+ oder +ref+ möglich.
* Eine neue Instanz der _Bean_ wird erzeugt... später dazu mehr im Scope
* _Bean_ wir direkt injected.

++++
<script src="https://gist.github.com/KacperBak/ecc137958a60b36d759f.js"></script>
++++

.Constructor Injection mit _Id_'s
* Da das Matching der _Constructor Injection_ vom Typ der Instanz abhängt muss hier jegliche Doppeldeutigkeit eleminiert werden.
* Hypthetischer Fall mit *zwei* Konstruktorparametern vom Typ: +BookingDate+

++++
<script src="https://gist.github.com/KacperBak/28eae07dcad83d2cdb87.js"></script>
++++

* Das Angeben des Parameter-Indexes +index="0"+ und +index="1"+ löst diesen Fall eindeutig auf.

++++
<script src="https://gist.github.com/KacperBak/27e2c78a4ee287967132.js"></script>
++++

== Anwendung

* _Constructor Injection_ für *obligatorische* Abhängigkeiten
* _Setter Injection_ für *optionale* Abhängigkeiten und *m:n* Beziehungen
* _Inner bean_ für Beans welche nach Außen nicht sichtbar sein sollen.
* Die Kombination aller Arten ist möglich.
* Einige _Beans_ aus dem Spring Framework geben eine Art der Injection vor, dieser sollte gefolgt werden.
* Ein konsistenter Stil erhöht die Lesbarkeit.

== Domain Model mit Spring Integration
* Spring gibt bei einer typischen CRUD-Anwendung eine Basis-Architektur vor.
* Diese kapselt das tatsächliche Storage-Device (DB, File, ...) von der restlichen Anwendung ab.
* Dafür werden _Services_ erstellt, welche wiederum _Repositories_ enthalten und letztendlich die CRUD Operationen ausführen.
* Hier setzt Spring mittels des _Repositories_ das _Data Access Object_ JEE Core Pattern um.

image::02-spring-basics-005.png[02-spring-basics-005.png, align="center"]

* Alle Elemente welche mit *_uses_* auf ein weitere Element referenzieren, stellen eine Abhängigkeit dar.
* Diese Abhängigkeiten können nun elegant mittls Spring XML DI aufgelöst werden.
* Die Anwendung könnte man als klassische 3-Tier Architektur bezeichnen Client -> Service -> Repo
* In diesem Fall existiert pro Domain-Objekt ein Repository, Beispiel Person.


== Konfigurationswerte Auslagern
* Eine Best-Practice in der Java Welt ist es die Konfiguration einer Anwendung in einem Property-File zu halten.
* Somit sind klasische Werte wie die Datenbank-URL oder der Pfad zu einer Datei in der +Key=Value+ Form zu pflegen.
* Das Anpassen einer umfangreichen DI-XML wäre unter Umständen auch gefährlich. (Admin sieht nur Werte, keine Zusammenhänge)

[horizontal]
1.:: Anlegen eines Property-Files
++++
<script src="https://gist.github.com/KacperBak/1d232c15df4d189f54d3.js"></script>
++++

[horizontal]
2.:: Hinzufügen des +context+ Namespaces
++++
<script src="https://gist.github.com/KacperBak/9d3b300f899a2696f823.js"></script>
++++

[horizontal]
3.:: Verwendung des +property-placeholder+ unter Angabe des Property-Files
++++
<script src="https://gist.github.com/KacperBak/463b879d659d75928362.js"></script>
++++

[horizontal]
4.:: Ersetzen des tatsächlen Wertes mit dem _Key_ aus dem Property-File
++++
<script src="https://gist.github.com/KacperBak/a5f6209171e733882bb0.js"></script>
++++

== ApplicationContext

* Spring _ApplicationContext_ = Container
* Der Container nimmt dabei Anwendungsklassen (_POJO_'s) und die Konfigurationsanweisungen entgegen.
* Der Container kümmert sich um die Erstellung und die Lebenszeit aller Objekte.
* Der ApplicationContext kann in unterschiedlichen *Umgebungen*/*_Environments_* verwendet werden.
** JUnit test system (siehe JUnit Tests)
** Web application
** Standalone application

== ApplicationContext - Konfiguration
* Eine Best Practice ist es die AC-Konfiguration in mehrere Dateien aufteilen, da sich diese von Umgebung zu Umgebung meist unterscheidet.
* Bsp.: Für JUnit-Tests wird eine Embedded-DB verwendet während in Prod eine physische DB zum Einsatz kommt.

.Anwendung
* Trennung der XML-Konfigurations-Datei in +application+ und +infrastructure+ _Beans_.

.test-infrastructure-config.xml
Konfiguration einer Embedded-DB
++++
<script src="https://gist.github.com/KacperBak/aa6092d58b2585a0e37a.js"></script>
++++

.prod-infrastructure-config.xml
Konfiguration einer physikalischen DB
++++
<script src="https://gist.github.com/KacperBak/fa7eec6001bd4248ccd8.js"></script>
++++

.application-config.xml
Konfiguration der Java Klassen
++++
<script src="https://gist.github.com/KacperBak/92ddb52929269f63713c.js"></script>
++++

.Folge
Umgebungsspezifisches +bootstrapping+ der AC möglich
++++
<script src="https://gist.github.com/KacperBak/7e30948f0bc53a03e164.js"></script>
++++

== ApplicationContext - Laden der Ressourcen

//weiter

* Unterschiedliche AC:

* Tabelle ZUSA

* Weitere Mechnaismen
** <import> Tag
** Prefixe
** Wildcards


== ApplicationContext - Bean Scope

== singleton and factory-method

...

[NOTE]
====
* Der Singleton Scope stellt sicher, dass eine Bean einmalig im ApplicationContext ist.
* Das _Gang of Four_ Singleton-Pattern stellt sicher, dass eine Instanz einmalig in der Applikation ist.
* Da mehr als ein ApplicationContext in der Applikation vorhanden sein kann, ist dieser Unterschied wichtig!
====

//////////////////////////////////////////////////////////////

== bean inheritance

== Überletiung mit c:p NameSpaces